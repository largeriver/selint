#!/usr/bin/python2
#
# Written by Filippo Bonazzi
# Copyright (C) 2016 Aalto University
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
"""TODO: file docstring"""

import os
import os.path
import sys
import argparse
import logging
import shutil
import policysource
import policysource.policy
import plugins

# Parse arguments
parser = argparse.ArgumentParser(
    description="SELinux source policy analysis tool.",
    epilog="If not differently specified, all available plugins will be run.")
# List the available plugins
parser.add_argument("-l", "--list", action="store_true",
                    help="list the available plugins and exit.")
# Select the plugins to run (default: all). Specify either with a whitelist
# or a blacklist, but not both
plugin_group = parser.add_mutually_exclusive_group()
# Plugin whitelist
plugin_group.add_argument(
    "-w", "--whitelist", metavar="<PLUGIN>", choices=plugins.available_plugins,
    nargs="+", help="specify the plugins to run [Default: run all].")
# Plugin blacklist
plugin_group.add_argument(
    "-b", "--blacklist", metavar="<PLUGIN>", choices=plugins.available_plugins,
    nargs="+", help="specify the plugins not to run [Default: run all].")
# Get additional M4 definitions
parser.add_argument("-D", "--define", metavar="NAME[=VALUE]", nargs="+",
                    dest="extra_defs",
                    help="Pass additional definitions to M4 when expanding the"
                    " policy. Identical to the -D option in m4.")
# Write out the policy.conf file
parser.add_argument("--dumppolicyconf", metavar="<FILE>",
                    help="write the policy.conf to a user-specified file. "
                    "If the file already exists, IT WILL BE OVERWRITTEN.")
# Write out the full list of recognized policy files to be processed
parser.add_argument("--listpolicyfiles", action="store_true",
                    help="List all the recognized policy files and exit.")
# Set the verbosity level
parser.add_argument("-v", "--verbosity", metavar="<LVL>",
                    choices=[0, 1, 2, 3, 4], type=int, default=-1,
                    help="Be verbose. Supported levels are 0-4, "
                    "with 0 being the default.")
# Supply a different config file
parser.add_argument("-c", "--config", metavar="<FILE>", type=str,
                    default="config.py", help="Source the specified config "
                    "file [Default: config.py].")

args = parser.parse_args()

# Handle "list" option right away
if args.list:
    # List available plugins and exit
    print "Available plugins:"
    print "\n".join(plugins.available_plugins)
    sys.exit(0)

if args.whitelist:
    selected_plugins = list(args.whitelist)
elif args.blacklist:
    selected_plugins = [
        x for x in plugins.available_plugins if x not in args.blacklist]
else:
    selected_plugins = list(plugins.available_plugins)

# Import config file as "config"
try:
    config = __import__(args.config[:-3])
except:
    print "CRITICAL: Malformed configuration file "\
        "\"{}\", aborting ...".format(args.config)
    raise

# Save verbosity in config
if hasattr(config, "VERBOSITY"):
    # If we have a verbosity configuration value
    if args.verbosity == -1:
        # User didn't explicitly set verbosity on the command line
        if isinstance(config.VERBOSITY, int) and \
                config.VERBOSITY >= 0 and config.VERBOSITY <= 4:
            # If we have a valid verbosity in the config file
            args.verbosity = config.VERBOSITY
    else:
        # User explictly set verbosity on the command line
        config.VERBOSITY = args.verbosity
else:
    # If we have no verbosity configuration value
    if args.verbosity == -1:
        # User didn't explicitly set verbosity on the command line: reset it
        # to the default value
        args.verbosity = 0
    # Set the configuration value of verbosity
    config.VERBOSITY = args.verbosity
# Save extra_defs in config
if hasattr(config, "EXTRA_DEFS"):
    # If we have an extra_defs configuration value
    if args.extra_defs is None:
        # User didn't explicitly set extra_defs on the command line
        args.extra_defs = config.EXTRA_DEFS
    else:
        # User explictly set extra_defs on the command line: combine the two
        args.extra_defs.extend(config.EXTRA_DEFS)
else:
    # If we have no extra_defs configuration value
    if args.extra_defs is None:
        # User didn't explicitly set extra_defs on the command line: set it
        # to an empty list
        args.extra_defs = []
    # Set the configuration value of extra_defs
    config.EXTRA_DEFS = args.extra_defs

# Setup logging
if args.verbosity == 4:
    logging.basicConfig(level=logging.DEBUG)
elif args.verbosity == 3:
    logging.basicConfig(level=logging.INFO)
elif args.verbosity == 2:
    logging.basicConfig(level=logging.WARNING)
elif args.verbosity == 1:
    logging.basicConfig(level=logging.ERROR)
elif args.verbosity == 0:
    logging.basicConfig(level=logging.CRITICAL)

# Compute list of policy files
# TODO: add CLI option in addition to config file
ALL_POLICY_FILES = []
if not config.BASE_DIR_GLOBAL:
    # If the directory is None or the name is empty
    logging.error("Bad policy base directory.")
    sys.exit(1)
# Expand and sanitize the directory name
FULL_BASE_DIR = os.path.abspath(os.path.expanduser(config.BASE_DIR_GLOBAL))
# If the directory does not exist or is not traversable/readable
if (not os.access(FULL_BASE_DIR, os.F_OK)
        or not os.access(FULL_BASE_DIR, os.X_OK | os.R_OK)):
    logging.error("Bad policy base directory \"%s\"", FULL_BASE_DIR)
    sys.exit(1)
# Check that we have at least one file/directory
if not config.TEFILES_DIRS and not config.POLICYFILES_STATIC_PRE and not config.POLICYFILES_STATIC_POST:
    logging.error("No policy files specified.")
    sys.exit(1)
# Add the static policy files that go before the .te files
for f in config.POLICYFILES_STATIC_PRE:
    if f:
        full_f = os.path.abspath(os.path.join(FULL_BASE_DIR, f))
        if os.path.isfile(full_f):
            # TODO: add access checks from policysource/policy.py:131
            ALL_POLICY_FILES.append(full_f)
# Pick up the .te files from the supplied directories
for d in config.TEFILES_DIRS:
    full_d = os.path.abspath(os.path.join(FULL_BASE_DIR, d))
    files = sorted(os.listdir(full_d))
    for f in files:
        if f:
            full_f = os.path.join(full_d, f)
            if f.endswith(".te") and os.path.isfile(full_f):
                # TODO: add access checks from policysource/policy.py:131
                ALL_POLICY_FILES.append(full_f)
# Add the static .te files, if any
for f in config.POLICYFILES_STATIC_TE:
    if f:
        full_f = os.path.abspath(os.path.join(FULL_BASE_DIR, f))
        if os.path.isfile(full_f):
            # TODO: add access checks from policysource/policy.py:131
            ALL_POLICY_FILES.append(full_f)
# Add the static policy files that go after the .te files
for f in config.POLICYFILES_STATIC_POST:
    if f:
        full_f = os.path.abspath(os.path.join(FULL_BASE_DIR, f))
        if os.path.isfile(full_f):
            # TODO: add access checks from policysource/policy.py:131
            ALL_POLICY_FILES.append(full_f)
# Final sanity check
if not ALL_POLICY_FILES:
    logging.error("No policy files found.")
    sys.exit(1)
# TODO: add debug options, print this with debug?
# print "\n".join(ALL_POLICY_FILES)
if args.listpolicyfiles:
    print "\n".join(ALL_POLICY_FILES)
    sys.exit(0)

# Create policy
policy = policysource.policy.SourcePolicy(ALL_POLICY_FILES, args.extra_defs)
# Write the policy.conf to file, if requested
if args.dumppolicyconf:
    try:
        shutil.copyfile(policy.policyconf, args.dumppolicyconf)
    except shutil.Error as e:
        logging.error("%s", e)
        logging.error("Could not dump policy.conf")
    except IOError as e:
        logging.error("%s", e)
        logging.error("Could not dump policy.conf")
    else:
        logging.info("Wrote policy.conf to %s", args.dumppolicyconf)

# Run plugins
for plg in selected_plugins:
    print "Running plugin " + plg + "..."
    plugins.get_plugin(plg).main(policy, config)
